"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QGISStyleParser = exports.outlineStyleDashArrays = void 0;
var geostyler_cql_parser_1 = require("geostyler-cql-parser");
var Color = require('color');
var xml2js_1 = require("xml2js");
var _get = require('lodash/get');
exports.outlineStyleDashArrays = {
    dot: [2, 2],
    dash: [10, 2]
};
var AnchorMap = {
    left: 'L',
    right: 'R',
    top: 'T',
    bottom: 'B',
    'top-left': 'TL',
    'top-right': 'TR',
    'bottom-left': 'BL',
    'bottom-right': 'BR'
};
/**
 * This parser can be used with the GeoStyler.
 * It implements the GeoStyler-Style StyleParser interface.
 *
 * @class QGISStyleParser
 * @implements StyleParser
 */
var QGISStyleParser = /** @class */ (function() {
    function QGISStyleParser() {
        this.cqlParser = new geostyler_cql_parser_1.CqlParser();
        this.title = 'QGIS Style Parser';
    }
    /**
     * The readStyle implementation of the GeoStyler-Style StyleParser interface.
     * It reads a QML as a string and returns a Promise.
     * The Promise itself resolves with a GeoStyler-Style Style.
     *
     * @param {string} qmlString A QML as a string.
     * @return {Promise} The Promise resolving with the GeoStyler-Style Style
     */
    QGISStyleParser.prototype.readStyle = function(qmlString) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            var options = {};
            try {
                xml2js_1.parseString(qmlString, options, function(err, result) {
                    if (err) {
                        reject("Error while parsing qmlString: " + err);
                    }
                    var geoStylerStyle = _this.qmlObjectToGeoStylerStyle(result);
                    resolve(geoStylerStyle);
                });
            } catch (error) {
                reject(error);
            }
        });
    };
    /**
     *
     * @param qmlLabel
     */
    QGISStyleParser.prototype.parseLabelTemplates = function(qmlLabel) {
        var geostylerLabel = '';
        var qmlLabelArray = qmlLabel.split('||');
        qmlLabelArray.forEach(function(part) {
            var singleQuotedText = part.match(/[']([^']+)[']/);
            if (singleQuotedText) {
                geostylerLabel += singleQuotedText[1];
            } else {
                geostylerLabel += "{{" + part.trim() + "}}";
            }
        });
        return geostylerLabel;
    };
    /**
     *
     * @param qmlSymbolizer
     */
    QGISStyleParser.prototype.qmlSymbolizerLayerPropsToObject = function(qmlSymbolizer) {
        var qmlMarkerProps = {};
        qmlSymbolizer.prop.forEach(function(prop) {
            var key = prop.$.k;
            var value = prop.$.v;
            qmlMarkerProps[key] = value;
        });
        return qmlMarkerProps;
    };
    /**
     * Get the GeoStyler-Style Style from an QML Object (created with xml2js).
     *
     * @param {object} qmlObject The QML object representation (created with xml2js)
     * @return {Style} The GeoStyler-Style Style
     */
    QGISStyleParser.prototype.qmlObjectToGeoStylerStyle = function(qmlObject) {
        var rules = this.getRulesFromQmlObject(qmlObject);
        return {
            name: 'QGIS Style',
            rules: rules
        };
    };
    /**
     *
     * @param hex
     * @param opacity
     */
    QGISStyleParser.prototype.qmlColorFromHexAndOpacity = function(hex, opacity) {
        var colorArray = Color(hex).alpha(opacity).rgb().array();
        var alpha = colorArray[3] === undefined || isNaN(colorArray[3]) ? 255 :
            colorArray[3] === 0 ? 0 :
            255 * colorArray[3];
        var color = colorArray[0] + "," + colorArray[1] + "," + colorArray[2] + "," + Math.round(alpha);
        return color;
    };
    /**
     *
     * @param color
     */
    QGISStyleParser.prototype.qmlColorToOpacity = function(color) {
        var colorArray = color.split(',');
        var opacity = parseFloat(colorArray[3]) / 255;
        return Math.round(opacity * 100) / 100;
    };
    /**
     *
     * @param color
     */
    QGISStyleParser.prototype.qmlColorToHex = function(qmlColor) {
        var colorArray = qmlColor.split(',');
        var color = Color("rgb(" + colorArray[0] + "," + colorArray[1] + "," + colorArray[2] + ")");
        return color.hex();
    };
    /**
     * Get the GeoStyler-Style Rule from an QML Object (created with xml2js).
     *
     * @param {object} qmlObject The QML object representation (created with xml2js)
     * @return {Rule} The GeoStyler-Style Rule
     */
    function isNumeric(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }
    QGISStyleParser.prototype.getRulesFromQmlObject = function(qmlObject) {
        var _this = this;
        var qmlRenderer = _get(qmlObject, 'qgis.renderer-v2.[0]');
        var qmlRules = _get(qmlRenderer, 'rules[0].rule');
        var qmlCategories = _get(qmlRenderer, 'categories[0].category');
        var qmlRanges = _get(qmlRenderer, 'ranges[0].range');
        var qmlSymbols = _get(qmlRenderer, 'symbols[0].symbol');
        var qmlLabeling = _get(qmlObject, 'qgis.labeling.[0]');
        var rules = [];
        var symbolizerMap = {};
        var labelMap = {};
        if (Array.isArray(qmlSymbols)) {
            symbolizerMap = this.parseQmlSymbolizers(qmlSymbols);
        }
        if (qmlLabeling) {
            labelMap = this.parseQmlLabeling(qmlLabeling);
        }

        if (Array.isArray(qmlRules) && qmlRules.length > 0) {
            qmlRules.forEach(function(qmlRule, index) {
                var filter = _this.getFilterFromQmlRule(qmlRule);
                var scaleDenominator = _this.getScaleDenominatorFromRule(qmlRule);
                var name = qmlRule.$.label || qmlRule.$.filter;
                var rule = {
                    name: name
                };
                if (filter) {
                    rule.filter = filter;
                }
                if (scaleDenominator) {
                    rule.scaleDenominator = scaleDenominator;
                }
                if (Object.keys(symbolizerMap).length > 0 && symbolizerMap[qmlRule.$.symbol]) {
                    rule.symbolizers = symbolizerMap[qmlRule.$.symbol];
                }

                rules.push(rule);
            });
        } else if (Array.isArray(qmlCategories) && qmlCategories.length > 0) {
            var attribute_1 = _get(qmlObject, 'qgis.renderer-v2.[0].$.attr');
            qmlCategories.forEach(function(qmlCategory, index) {

                if (isNumeric(qmlCategory.$.value)) {
                    var value = parseFloat(qmlCategory.$.value);
                } else {
                    var value = qmlCategory.$.value;
                }
                var filter = ['==', attribute_1, value];
                var name = attribute_1 + " = " + value;
                var rule = {
                    name: name,
                    filter: filter
                };
                if (symbolizerMap && symbolizerMap[qmlCategory.$.symbol]) {
                    rule.symbolizers = symbolizerMap[qmlCategory.$.symbol];
                }
                console.log(rule);

                rules.push(rule);
            });
        } else if (Array.isArray(qmlRanges) && qmlRanges.length > 0) {
            var attribute_2 = _get(qmlObject, 'qgis.renderer-v2.[0].$.attr');
            qmlRanges.forEach(function(qmlRange, index) {
                var name = qmlRange.$.label;
                var lower = qmlRange.$.lower;
                var upper = qmlRange.$.upper;
                var filter = [
                    '&&', ['>=', attribute_2, lower],
                    ['<=', attribute_2, upper]
                ];
                var rule = {
                    name: name,
                    filter: filter
                };
                if (symbolizerMap && symbolizerMap[qmlRange.$.symbol]) {
                    rule.symbolizers = symbolizerMap[qmlRange.$.symbol];
                }
                rules.push(rule);
            });
        } else {
            var symbolizers = symbolizerMap[Object.keys(symbolizerMap)[0]] || [];
            var labels = labelMap[Object.keys(labelMap)[0]] || [];
            var rule = {
                name: 'QGIS Simple Symbol',
                symbolizers: __spreadArrays(symbolizers, labels)
            };
            try {
                var filter = this.cqlParser.read(Object.keys(labelMap)[0]);
                if (filter) {
                    rule.filter = filter;
                }
            } catch (e) {
                // in the case of made up filters
            }
            rules.push(rule);
        }
        return rules;
    };
    /**
     * Get the GeoStyler-Style Filter from an QML Rule.
     *
     * Currently only supports one Filter per Rule.
     *
     * @param {object} qmlRule The QML Rule
     * @return {Filter} The GeoStyler-Style Filter
     */
    QGISStyleParser.prototype.getFilterFromQmlRule = function(qmlRule) {
        var qmlFilter = _get(qmlRule, '$.filter');
        var filter;
        if (qmlFilter) {
            filter = this.cqlParser.read(qmlFilter);
            return filter;
        }
        return undefined;
    };
    /**
     * Get the GeoStyler-Style ScaleDenominator from an QML Rule.
     *
     * @param {object} qmlRule The QML Rule
     * @return {ScaleDenominator} The GeoStyler-Style ScaleDenominator
     */
    QGISStyleParser.prototype.getScaleDenominatorFromRule = function(qmlRule) {
        var maxScaleDenominator = _get(qmlRule, '$.scalemaxdenom');
        var minScaleDenominator = _get(qmlRule, '$.scalemindenom');
        var scaleDenominator = {};
        if (minScaleDenominator) {
            scaleDenominator.min = parseFloat(minScaleDenominator);
        }
        if (maxScaleDenominator) {
            scaleDenominator.max = parseFloat(maxScaleDenominator);
        }
        return (scaleDenominator.min || scaleDenominator.max) ?
            scaleDenominator :
            undefined;
    };
    /**
     *
     * @param qmlLabels
     */
    QGISStyleParser.prototype.parseQmlLabeling = function(qmlLabeling) {
        var _this = this;
        var type = qmlLabeling.$.type;
        var labelMap = {};
        if (type === 'rule-based') {
            var rules = _get(qmlLabeling, 'rules[0].rule');
            rules.forEach(function(rule, index) {
                var settings = _get(rule, 'settings[0]');
                var textSymbolizer = _this.getTextSymbolizerFromLabelSettings(settings);
                labelMap[rule.$.filter || index] = [textSymbolizer];
            });
        }
        if (type === 'simple') {
            var settings = _get(qmlLabeling, 'settings[0]');
            var textSymbolizer = this.getTextSymbolizerFromLabelSettings(settings);
            labelMap.a = [textSymbolizer];
        }
        return labelMap;
    };
    /**
     *
     * @param settings
     */
    QGISStyleParser.prototype.getTextSymbolizerFromLabelSettings = function(settings) {
        var textSymbolizer = {
            kind: 'Text',
        };
        var styleProperties = _get(settings, 'text-style[0].$');
        var placementProperties = _get(settings, 'placement[0].$');
        if (styleProperties.textColor) {
            textSymbolizer.color = this.qmlColorToHex(styleProperties.textColor);
        }
        if (styleProperties.fieldName) {
            // TODO parse fieldName templates like: "'ID: ' || ID"
            textSymbolizer.label = this.parseLabelTemplates(styleProperties.fieldName);
        }
        if (styleProperties.fontSize) {
            textSymbolizer.size = parseFloat(styleProperties.fontSize);
        }
        if (styleProperties.fontFamily) {
            textSymbolizer.font = [styleProperties.fontFamily];
        }
        if (styleProperties.fontLetterSpacing && parseFloat(styleProperties.fontLetterSpacing) > 0) {
            textSymbolizer.letterSpacing = parseFloat(styleProperties.fontLetterSpacing);
        }
        if (styleProperties.multilineHeight && parseFloat(styleProperties.multilineHeight) > 0) {
            textSymbolizer.lineHeight = parseFloat(styleProperties.multilineHeight);
        }
        if (parseFloat(placementProperties.xOffset) > 0 || parseFloat(placementProperties.yOffset) > 0) {
            textSymbolizer.offset = [
                parseFloat(placementProperties.xOffset),
                parseFloat(placementProperties.yOffset)
            ];
        }
        return textSymbolizer;
    };
    /**
     *
     */
    QGISStyleParser.prototype.parseQmlSymbolizers = function(qmlSymbolizers) {
        var _this = this;
        var symbolizerMap = {};
        qmlSymbolizers.forEach(function(qmlSymbolizer) {
            var symbolizerKey = _get(qmlSymbolizer, '$.name');
            var symbolizerType = _get(qmlSymbolizer, '$.type');
            var symbolizers;
            switch (symbolizerType) {
                case 'marker':
                    symbolizers = _this.getPointSymbolizersFromQmlSymbolizer(qmlSymbolizer);
                    break;
                case 'line':
                    symbolizers = _this.getLineSymbolizersFromQmlSymbolizer(qmlSymbolizer);
                    break;
                case 'fill':
                    symbolizers = _this.getFillSymbolizerFromQmlSymbolizer(qmlSymbolizer);
                    break;
                default:
                    throw new Error('Failed to parse SymbolizerKind from qmlSymbolizer');
            }
            symbolizerMap[symbolizerKey] = symbolizers;
        });
        return symbolizerMap;
    };
    /**
     * Get the GeoStyler-Style PointSymbolizer from an QGIS Symbolizer.
     *
     * The opacity of the Symbolizer is taken from the <Graphic>.
     *
     * @param {object} qmlSymbolizer The QGIS Symbolizer
     * @return {PointSymbolizer} The GeoStyler-Style PointSymbolizer
     */
    QGISStyleParser.prototype.getPointSymbolizersFromQmlSymbolizer = function(qmlSymbolizer) {
        var _this = this;
        return qmlSymbolizer.layer.map(function(symbolizerLayer) {
            var markerClass = symbolizerLayer.$.class;
            switch (markerClass) {
                case 'SimpleMarker':
                    return _this.getPointSymbolizerFromMarkLayer(symbolizerLayer);
                case 'SvgMarker':
                    return _this.getPointSymbolizerFromSvgLayer(symbolizerLayer);
                default:
                    throw new Error("Failed to parse MarkerClass " + markerClass + " from qmlSymbolizer");
            }
        });
    };
    /**
     * Get the GeoStyler-Style MarkSymbolizer from an QML Symbolizer
     *
     * @param {object} symbolizerLayer The QML SymbolizerLayer
     * @return {MarkSymbolizer} The GeoStyler-Style MarkSymbolizer
     */
    QGISStyleParser.prototype.getPointSymbolizerFromMarkLayer = function(symbolizerLayer) {
        var markSymbolizer = {
            kind: 'Mark',
        };
        var qmlMarkerProps = this.qmlSymbolizerLayerPropsToObject(symbolizerLayer);
        var wellKnownName = qmlMarkerProps.name;
        var wkn = wellKnownName.charAt(0).toUpperCase() + wellKnownName.slice(1);
        markSymbolizer.wellKnownName = wkn;
        if (qmlMarkerProps.color) {
            markSymbolizer.opacity = this.qmlColorToOpacity(qmlMarkerProps.color);
            markSymbolizer.color = this.qmlColorToHex(qmlMarkerProps.color);
        }
        if (qmlMarkerProps.angle) {
            markSymbolizer.rotate = parseFloat(qmlMarkerProps.angle);
        }
        if (qmlMarkerProps.size) {
            markSymbolizer.radius = parseFloat(qmlMarkerProps.size) / 2;
        }
        // TODO Fix in style declaration
        // if (qmlMarkerProps.offset) {
        //   markSymbolizer.offset = qmlMarkerProps.offset.split(',').map(parseFloat);
        // }
        if (qmlMarkerProps.outline_color) {
            markSymbolizer.strokeOpacity = this.qmlColorToOpacity(qmlMarkerProps.outline_color);
            markSymbolizer.strokeColor = this.qmlColorToHex(qmlMarkerProps.outline_color);
        }
        if (qmlMarkerProps.outline_width) {
            markSymbolizer.strokeWidth = parseFloat(qmlMarkerProps.outline_width);
        }
        return markSymbolizer;
    };
    /**
     * Get the GeoStyler-Style IconSymbolizer from an QML Symbolizer
     *
     * @param {object} qmlSymbolizer The QML Symbolizer
     * @return {LineSymbolizer} The GeoStyler-Style LineSymbolizer
     */
    QGISStyleParser.prototype.getLineSymbolizersFromQmlSymbolizer = function(qmlSymbolizer) {
        var _this = this;
        var qmlSymbolizerLayerPropsToObject = this.qmlSymbolizerLayerPropsToObject;
        return qmlSymbolizer.layer.map(function(symbolizerLayer) {
            var lineSymbolizer = {
                kind: 'Line',
            };
            var qmlMarkerProps = qmlSymbolizerLayerPropsToObject(symbolizerLayer);
            if (qmlMarkerProps.line_color) {
                lineSymbolizer.opacity = _this.qmlColorToOpacity(qmlMarkerProps.line_color);
                lineSymbolizer.color = _this.qmlColorToHex(qmlMarkerProps.line_color);
            }
            if (qmlMarkerProps.capstyle) {
                lineSymbolizer.cap = qmlMarkerProps.capstyle;
            }
            if (qmlMarkerProps.joinstyle) {
                lineSymbolizer.join = qmlMarkerProps.joinstyle;
            }
            if (qmlMarkerProps.customdash) {
                lineSymbolizer.dasharray = qmlMarkerProps.customdash.split(';').map(parseFloat);
            }
            if (qmlMarkerProps.offset) {
                lineSymbolizer.perpendicularOffset = parseFloat(qmlMarkerProps.offset);
            }
            if (qmlMarkerProps.line_width) {
                lineSymbolizer.width = parseFloat(qmlMarkerProps.line_width);
            }
            return lineSymbolizer;
        });
    };
    /**
     * Get the GeoStyler-Style IconSymbolizer from an QML Symbolizer
     *
     * @param {object} qmlSymbolizer The QML Symbolizer
     * @return {FillSymbolizer} The GeoStyler-Style FillSymbolizer
     */
    QGISStyleParser.prototype.getFillSymbolizerFromQmlSymbolizer = function(qmlSymbolizer) {
        var _this = this;
        var qmlSymbolizerLayerPropsToObject = this.qmlSymbolizerLayerPropsToObject;
        return qmlSymbolizer.layer.map(function(symbolizerLayer) {
            var fillSymbolizer = {
                kind: 'Fill',
            };
            var qmlMarkerProps = qmlSymbolizerLayerPropsToObject(symbolizerLayer);
            if (qmlMarkerProps.outline_color) {
                fillSymbolizer.outlineColor = _this.qmlColorToHex(qmlMarkerProps.outline_color);
            }
            if (qmlMarkerProps.color) {
                fillSymbolizer.opacity = _this.qmlColorToOpacity(qmlMarkerProps.color);
                fillSymbolizer.color = _this.qmlColorToHex(qmlMarkerProps.color);
            }
            if (qmlMarkerProps.outline_style) {
                switch (qmlMarkerProps.outline_style) {
                    case 'dot':
                        fillSymbolizer.outlineDasharray = exports.outlineStyleDashArrays.dot;
                        break;
                    case 'dash':
                        fillSymbolizer.outlineDasharray = exports.outlineStyleDashArrays.dash;
                        break;
                    case 'dash dot':
                        fillSymbolizer.outlineDasharray = __spreadArrays(exports.outlineStyleDashArrays.dash, exports.outlineStyleDashArrays.dot);
                        break;
                    case 'dash dot dot':
                        fillSymbolizer.outlineDasharray = __spreadArrays(exports.outlineStyleDashArrays.dash, exports.outlineStyleDashArrays.dot, exports.outlineStyleDashArrays.dot);
                        break;
                    default:
                        break;
                }
            }
            if (qmlMarkerProps.outline_width) {
                fillSymbolizer.outlineWidth = parseFloat(qmlMarkerProps.outline_width);
            }
            return fillSymbolizer;
        });
    };
    /**
     * Get the GeoStyler-Style IconSymbolizer from an QML Symbolizer
     *
     * @param {object} symbolizerLayer The QML Symbolizer Layer
     * @return {IconSymbolizer} The GeoStyler-Style IconSymbolizer
     */
    QGISStyleParser.prototype.getPointSymbolizerFromSvgLayer = function(symbolizerLayer) {
        var iconSymbolizer = {
            kind: 'Icon',
        };
        var qmlMarkerProps = this.qmlSymbolizerLayerPropsToObject(symbolizerLayer);
        if (qmlMarkerProps.color) {
            var colorArray = qmlMarkerProps.color.split(',');
            iconSymbolizer.opacity = parseFloat(colorArray[3]) / 255;
            var color = Color("rgb(" + colorArray[0] + "," + colorArray[1] + "," + colorArray[2] + ")");
            iconSymbolizer.color = color.hex();
        }
        if (qmlMarkerProps.angle) {
            iconSymbolizer.rotate = parseFloat(qmlMarkerProps.angle);
        }
        if (qmlMarkerProps.size) {
            iconSymbolizer.size = parseFloat(qmlMarkerProps.size);
        }
        if (qmlMarkerProps.offset) {
            var offsetArray = qmlMarkerProps.offset.split(',').map(parseFloat);
            if (offsetArray[0] > 0 || offsetArray[1] > 0) {
                iconSymbolizer.offset = qmlMarkerProps.offset.split(',').map(parseFloat);
            }
        }
        if (qmlMarkerProps.name) {
            iconSymbolizer.image = qmlMarkerProps.name;
        }
        return iconSymbolizer;
    };
    /**
     * The writeStyle implementation of the GeoStyler-Style StyleParser interface.
     * It reads a GeoStyler-Style Style and returns a Promise.
     * The Promise itself resolves with a QML string.
     *
     * @param {Style} geoStylerStyle A GeoStyler-Style Style.
     * @return {Promise} The Promise resolving with the QML as a string.
     */
    QGISStyleParser.prototype.writeStyle = function(geoStylerStyle) {
        var _this = this;
        return new Promise(function(resolve, reject) {
            try {
                var builder = new xml2js_1.Builder();
                var qmlObject = _this.geoStylerStyleToQmlObject(geoStylerStyle);
                _this.convertTextSymbolizers(qmlObject, geoStylerStyle);
                var qmlString = builder
                    .buildObject(qmlObject)
                    .replace("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>", "<!DOCTYPE qgis PUBLIC 'http://mrcc.com/qgis.dtd' 'SYSTEM'>");
                resolve(qmlString);
            } catch (error) {
                reject(error);
            }
        });
    };
    /**
     *
     * @param filter
     */
    QGISStyleParser.prototype.getQmlFilterFromFilter = function(filter) {
        return this.cqlParser.write(filter);
    };
    /**
     *
     */
    QGISStyleParser.prototype.getQmlRuleFromRule = function(rule, index) {
        var filter = rule.filter;
        var qmlRule = {
            $: {
                key: "renderer_rule_" + index,
                symbol: "" + index,
                label: rule.name
            }
        };
        if (rule.scaleDenominator) {
            if (rule.scaleDenominator.min) {
                qmlRule.$.scalemindenom = rule.scaleDenominator.min;
            }
            if (rule.scaleDenominator.max) {
                qmlRule.$.scalemaxdenom = rule.scaleDenominator.max;
            }
        }
        if (filter) {
            var cqlFilter = this.getQmlFilterFromFilter(filter);
            if (cqlFilter) {
                qmlRule.$.filter = this.getQmlFilterFromFilter(filter);
            }
        }
        return qmlRule;
    };
    /**
     *
     * @param geostylerStyle
     */
    QGISStyleParser.prototype.getQmlSymbolsFromStyle = function(geostylerStyle, rules) {
        var _this = this;
        return geostylerStyle.rules.map(function(rule, index) {
            var symbol = _this.getQmlSymbolFromRule(rule, index);
            if (symbol) {
                rules.push(_this.getQmlRuleFromRule(rule, index));
            }
            return symbol;
        }).filter(function(s) { return s; });
    };
    /**
     *
     * @param rule
     */
    QGISStyleParser.prototype.getQmlSymbolFromRule = function(rule, index) {
        var layer = this.getQmlLayersFromRule(rule);
        var type;
        if (!rule.symbolizers.length) {
            return;
        }
        switch (rule.symbolizers[0].kind) {
            case 'Line':
                type = 'line';
                break;
            case 'Fill':
                type = 'fill';
                break;
            default:
                type = 'marker';
        }
        return layer && layer[0] ? {
            $: {
                type: type,
                name: index.toString()
            },
            layer: layer
        } : undefined;
    };
    /**
     *
     */
    QGISStyleParser.prototype.getQmlLineSymbolFromSymbolizer = function(symbolizer) {
        var qmlProps = {
            line_color: this.qmlColorFromHexAndOpacity(symbolizer.color, symbolizer.opacity),
            offset: symbolizer.perpendicularOffset,
            offset_map_unit_scale: '3x:0,0,0,0,0,0',
            offset_unit: 'Pixel',
            joinstyle: symbolizer.join,
            capstyle: symbolizer.cap,
            line_width: symbolizer.width
        };
        if (symbolizer.dasharray) {
            qmlProps.customdash = symbolizer.dasharray.join(';');
        }
        return {
            $: {
                class: 'SimpleLine'
            },
            prop: this.propsObjectToQmlSymbolProps(qmlProps)
        };
    };
    QGISStyleParser.prototype.getQmlFillSymbolFromSymbolizer = function(symbolizer) {
        var qmlProps = {
            color: this.qmlColorFromHexAndOpacity(symbolizer.color, symbolizer.opacity),
            offset_map_unit_scale: '3x:0,0,0,0,0,0',
            offset_unit: 'Pixel',
            outline_style: symbolizer.outlineDasharray ? 'dash' : 'solid',
            outline_width: symbolizer.outlineWidth || '0',
            outline_width_map_unit_scale: '3x:0,0,0,0,0,0',
            outline_width_unit: 'Pixel',
            customdash: symbolizer.outlineDasharray ? symbolizer.outlineDasharray.join(';') : undefined,
            outline_color: this.qmlColorFromHexAndOpacity(symbolizer.outlineColor, 1)
        };
        return {
            $: {
                class: 'SimpleFill'
            },
            prop: this.propsObjectToQmlSymbolProps(qmlProps)
        };
    };
    /**
     *
     * @param rule
     */
    QGISStyleParser.prototype.getQmlLayersFromRule = function(rule) {
        var symbolizers = rule.symbolizers.map(this.getQmlLayerFromSymbolizer.bind(this)).filter(function(s) { return s; });
        return symbolizers.length ? symbolizers : undefined;
    };
    /**
     *
     * @param symbolizer
     */
    QGISStyleParser.prototype.getQmlLayerFromSymbolizer = function(symbolizer) {
        switch (symbolizer.kind) {
            case 'Fill':
                return this.getQmlFillSymbolFromSymbolizer(symbolizer);
            case 'Icon':
                return this.getQmlMarkSymbolFromIconSymbolizer(symbolizer);
            case 'Line':
                return this.getQmlLineSymbolFromSymbolizer(symbolizer);
            case 'Mark':
                return this.getQmlMarkSymbolFromSymbolizer(symbolizer);
            default:
                break;
        }
    };
    QGISStyleParser.prototype.getQmlMarkSymbolFromIconSymbolizer = function(symbolizer) {
        var qmlProps = {
            angle: symbolizer.rotate || 0,
            color: this.qmlColorFromHexAndOpacity(symbolizer.color, symbolizer.opacity),
            name: symbolizer.image,
            size: symbolizer.size,
            size_map_unit_scale: '3x:0,0,0,0,0,0',
            size_unit: 'Pixel'
        };
        return {
            $: {
                class: 'SvgMarker'
            },
            prop: this.propsObjectToQmlSymbolProps(qmlProps)
        };
    };
    /**
     *
     */
    QGISStyleParser.prototype.getQmlMarkSymbolFromSymbolizer = function(symbolizer) {
        var qmlProps = {
            angle: symbolizer.rotate || 0,
            color: this.qmlColorFromHexAndOpacity(symbolizer.color, symbolizer.opacity),
            name: symbolizer.wellKnownName.toLowerCase(),
            outline_color: this.qmlColorFromHexAndOpacity(symbolizer.strokeColor, symbolizer.strokeOpacity),
            outline_style: 'solid',
            outline_width: symbolizer.strokeWidth || 0,
            outline_width_map_unit_scale: '3x:0,0,0,0,0,0',
            outline_width_unit: 'Pixel',
            size: symbolizer.radius ? symbolizer.radius * 2 : undefined,
            size_map_unit_scale: '3x:0,0,0,0,0,0',
            size_unit: 'Pixel'
        };
        return {
            $: {
                class: 'SimpleMarker'
            },
            prop: this.propsObjectToQmlSymbolProps(qmlProps)
        };
    };
    /**
     *
     * @param properties
     */
    QGISStyleParser.prototype.propsObjectToQmlSymbolProps = function(properties) {
        return Object.keys(properties).map(function(k) {
            var v = properties[k];
            return {
                $: {
                    k: k,
                    v: v
                }
            };
        }).filter(function(s) { return s.$.v !== undefined; });
    };
    /**
     * Get the QML Object (readable with xml2js) from an GeoStyler-Style Style
     *
     * @param {Style} geoStylerStyle A GeoStyler-Style Style.
     * @return {object} The object representation of a QML Style (readable with xml2js)
     */
    QGISStyleParser.prototype.geoStylerStyleToQmlObject = function(geoStylerStyle) {
        var type = 'RuleRenderer';
        var rules = [];
        var symbols = this.getQmlSymbolsFromStyle(geoStylerStyle, rules);
        return {
            qgis: {
                $: {},
                'renderer-v2': [{
                    $: {
                        type: type
                    },
                    rules: [{
                        $: {
                            key: 'renderer_rules'
                        },
                        rule: rules
                    }],
                    symbols: [{
                        symbol: symbols
                    }]
                }]
            }
        };
    };
    QGISStyleParser.prototype.convertTextSymbolizerRule = function(qmlRuleList, rule) {
        var _this = this;
        var textSymbolizer;
        rule.symbolizers.forEach(function(symbolizer) {
            if (symbolizer.kind === 'Text') {
                textSymbolizer = symbolizer;
                var textStyleAttributes = {
                    fontSize: textSymbolizer.size || 12,
                    fontLetterSpacing: textSymbolizer.letterSpacing || 0,
                    multilineHeight: textSymbolizer.lineHeight !== undefined ? textSymbolizer.lineHeight : 1,
                    textColor: textSymbolizer.color ? _this.qmlColorFromHexAndOpacity(textSymbolizer.color, 1) : '0,0,0,255'
                };
                if (textSymbolizer.font) {
                    textStyleAttributes.fontFamily = textSymbolizer.font[0];
                }
                if (textSymbolizer.label) {
                    textStyleAttributes.fieldName = textSymbolizer.label.replace('{{', '').replace('}}', '');
                }
                var textRule = {
                    $: {
                        key: "labeling_rule_" + qmlRuleList.length
                    },
                    settings: [{
                        'text-style': [{
                            $: textStyleAttributes
                        }],
                        placement: [{
                            $: {
                                predefinedPositionOrder: textSymbolizer.anchor ? AnchorMap[textSymbolizer.anchor] : 'TR,TL,BR,BL,R,L,TSR,BSR',
                                xOffset: textSymbolizer.offset ? "" + textSymbolizer.offset[0] : "0",
                                yOffset: textSymbolizer.offset ? "" + textSymbolizer.offset[1] : "0",
                                rotationAngle: textSymbolizer.rotate ? textSymbolizer.rotate : "0"
                            }
                        }]
                    }]
                };
                if (textSymbolizer.haloColor) {
                    textRule.settings['text-buffer'] = [{
                        $: {
                            bufferSize: textSymbolizer.haloWidth || "0",
                            bufferColor: _this.qmlColorFromHexAndOpacity(textSymbolizer.haloColor, 1)
                        }
                    }];
                }
                if (rule.filter) {
                    textRule.$.filter = _this.cqlParser.write(rule.filter);
                }
                qmlRuleList.push(textRule);
            }
        });
    };
    QGISStyleParser.prototype.convertTextSymbolizers = function(qmlObject, geoStylerStyle) {
        var _this = this;
        var textSymbolizerRules = [];
        geoStylerStyle.rules.forEach(function(rule) {
            rule.symbolizers.forEach(function(symbolizer) {
                if (symbolizer.kind === 'Text' && !textSymbolizerRules.includes(rule)) {
                    textSymbolizerRules.push(rule);
                }
            });
        });
        if (textSymbolizerRules.length > 0) {
            qmlObject.qgis.labeling = [{
                $: {
                    type: 'rule-based'
                },
                rules: [{
                    $: {
                        key: 'labeling_rules'
                    },
                    rule: []
                }]
            }];
            textSymbolizerRules.forEach(function(rule) {
                return _this.convertTextSymbolizerRule(qmlObject.qgis.labeling[0].rules[0].rule, rule);
            });
        }
    };
    /**
     * The name of the QGIS Style Parser.
     */
    QGISStyleParser.title = 'QGIS Style Parser';
    return QGISStyleParser;
}());
exports.QGISStyleParser = QGISStyleParser;
exports.default = QGISStyleParser;
//# sourceMappingURL=QGISStyleParser.js.map