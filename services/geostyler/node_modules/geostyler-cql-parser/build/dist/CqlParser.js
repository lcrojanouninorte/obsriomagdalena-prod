"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var CqlParser = /** @class */ (function () {
    function CqlParser() {
        this.tokens = [
            'PROPERTY', 'COMPARISON', 'VALUE', 'LOGICAL'
        ];
        this.patterns = {
            PROPERTY: /^[_a-zA-Z]\w*/,
            COMPARISON: /^(=|<>|<=|<|>=|>|LIKE)/i,
            IS_NULL: /^IS NULL/i,
            COMMA: /^,/,
            LOGICAL: /^(AND|OR)/i,
            VALUE: function (text) {
                if (lodash_1.isNumber(text)) {
                    return [text];
                }
                else if (lodash_1.isString(text)) {
                    var singleQuotedText = text.match(/[']([^']+)[']/);
                    var doubleQuotedText = text.match(/["]([^"]+)["]/);
                    if (singleQuotedText) {
                        return [singleQuotedText[0]];
                    }
                    else if (doubleQuotedText) {
                        return [doubleQuotedText][0];
                    }
                    else {
                        return [text.split(/[\s)]/)[0]];
                    }
                }
                else {
                    return false;
                }
            },
            LPAREN: /^\(/,
            RPAREN: /^\)/,
            SPATIAL: /^(BBOX|INTERSECTS|DWITHIN|WITHIN|CONTAINS)/i,
            NOT: /^NOT/i,
            BETWEEN: /^BETWEEN/i,
            END: /^$/
        };
        this.follows = {
            LPAREN: ['GEOMETRY', 'SPATIAL', 'PROPERTY', 'LPAREN', 'VALUE'],
            RPAREN: ['NOT', 'LOGICAL', 'END', 'RPAREN'],
            PROPERTY: ['COMPARISON', 'BETWEEN', 'COMMA', 'IS_NULL'],
            BETWEEN: ['VALUE'],
            IS_NULL: ['END'],
            COMPARISON: ['VALUE'],
            COMMA: ['GEOMETRY', 'PROPERTY', 'VALUE'],
            VALUE: ['LOGICAL', 'COMMA', 'RPAREN', 'END'],
            SPATIAL: ['LPAREN'],
            LOGICAL: ['PROPERTY', 'NOT', 'LPAREN', 'SPATIAL', 'VALUE'],
            NOT: ['PROPERTY', 'LPAREN'],
            GEOMETRY: ['COMMA', 'RPAREN']
        };
        this.operatorsMap = {
            '=': '==',
            '<>': '!=',
            '<': '<',
            '<=': '<=',
            '>': '>',
            '>=': '>=',
            'LIKE': '*='
        };
        this.operatorReverseMap = {};
        this.combinationOperatorsMap = {
            'AND': '&&',
            'OR': '||'
        };
        this.combinationOperatorsReverseMap = {};
        this.precedence = {
            'RPAREN': 3,
            'LOGICAL': 2,
            'COMPARISON': 1
        };
        var _a = this, combinationOperatorsMap = _a.combinationOperatorsMap, combinationOperatorsReverseMap = _a.combinationOperatorsReverseMap, operatorsMap = _a.operatorsMap, operatorReverseMap = _a.operatorReverseMap;
        Object.keys(operatorsMap)
            .forEach(function (operator) {
            var value = operatorsMap[operator];
            operatorReverseMap[value] = operator;
        });
        Object.keys(combinationOperatorsMap)
            .forEach(function (combinationOperator) {
            var value = combinationOperatorsMap[combinationOperator];
            combinationOperatorsReverseMap[value] = combinationOperator;
        });
        this.nextToken = this.nextToken.bind(this);
        this.tokenize = this.tokenize.bind(this);
        this.tryToken = this.tryToken.bind(this);
        this.buildAst = this.buildAst.bind(this);
        this.read = this.read.bind(this);
        this.write = this.write.bind(this);
    }
    CqlParser.prototype.tryToken = function (text, pattern) {
        if (pattern instanceof RegExp) {
            return pattern.exec(text);
        }
        else if (pattern) {
            return pattern(text);
        }
    };
    CqlParser.prototype.nextToken = function (text, patternNames) {
        var _a = this, patterns = _a.patterns, tryToken = _a.tryToken;
        var i;
        var token;
        var len = patternNames.length;
        for (i = 0; i < len; i++) {
            token = patternNames[i];
            var pattern = patterns[token];
            var matches = tryToken(text, pattern);
            if (matches) {
                var match = matches[0];
                var remainder = text.substr(match.length).replace(/^\s*/, '');
                return {
                    type: token,
                    text: match,
                    remainder: remainder
                };
            }
        }
        var msg = "ERROR: In parsing: [" + text + "], expected one of: ";
        for (i = 0; i < len; i++) {
            token = patternNames[i];
            msg += "\n    " + token + ": " + patterns[token];
        }
        throw new Error(msg);
    };
    CqlParser.prototype.tokenize = function (text) {
        var _a = this, nextToken = _a.nextToken, follows = _a.follows;
        var results = [];
        var expect = ['NOT', 'PROPERTY', 'LPAREN'];
        var token;
        do {
            token = nextToken(text, expect);
            text = token.remainder;
            expect = follows[token.type];
            if (token.type !== 'END' && !expect) {
                throw new Error('No follows list for ' + token.type);
            }
            results.push(token);
        } while (token.type !== 'END');
        return results;
    };
    CqlParser.prototype.buildAst = function (tokens) {
        var _a = this, precedence = _a.precedence, operatorsMap = _a.operatorsMap, combinationOperatorsMap = _a.combinationOperatorsMap;
        var operatorStack = [];
        var postfix = [];
        tokens.forEach(function (token) {
            switch (token.type) {
                case 'PROPERTY':
                case 'GEOMETRY':
                case 'VALUE':
                    postfix.push(token);
                    break;
                case 'COMPARISON':
                case 'BETWEEN':
                case 'IS_NULL':
                case 'LOGICAL':
                    var p = precedence[token.type];
                    while (operatorStack.length > 0 &&
                        (precedence[operatorStack[operatorStack.length - 1].type] <= p)) {
                        postfix.push(operatorStack.pop());
                    }
                    operatorStack.push(token);
                    break;
                case 'SPATIAL':
                case 'NOT':
                case 'LPAREN':
                    operatorStack.push(token);
                    break;
                case 'RPAREN':
                    while (operatorStack.length > 0 &&
                        (operatorStack[operatorStack.length - 1].type !== 'LPAREN')) {
                        postfix.push(operatorStack.pop());
                    }
                    operatorStack.pop(); // toss out the LPAREN
                    if (operatorStack.length > 0 &&
                        operatorStack[operatorStack.length - 1].type === 'SPATIAL') {
                        postfix.push(operatorStack.pop());
                    }
                    break;
                case 'COMMA':
                case 'END':
                    break;
                default:
                    throw new Error('Unknown token type ' + token.type);
            }
        });
        while (operatorStack.length > 0) {
            postfix.push(operatorStack.pop());
        }
        var buildTree = function () {
            var token = postfix.pop();
            if (token) {
                var property = void 0;
                switch (token.type) {
                    case 'LOGICAL':
                        var rhs = buildTree(), lhs = buildTree();
                        var combinationOperator = combinationOperatorsMap[token.text];
                        return [combinationOperator, lhs, rhs];
                    case 'NOT':
                        var operand = buildTree();
                        return ['!', operand];
                    case 'BETWEEN':
                        var min = void 0;
                        var max = void 0;
                        postfix.pop(); // unneeded AND token here
                        max = buildTree();
                        min = buildTree();
                        property = buildTree();
                        return [
                            '&&',
                            ['>=', property, min],
                            ['<=', property, max]
                        ];
                    case 'COMPARISON':
                        var value = buildTree();
                        property = buildTree();
                        var operator = operatorsMap[token.text.toUpperCase()];
                        return [operator, property, value];
                    case 'IS_NULL':
                        property = buildTree();
                        return ['==', property, null];
                    case 'VALUE':
                        var num = parseFloat(token.text);
                        if (lodash_1.isNaN(num)) {
                            return token.text.replace(/['"]/g, '');
                        }
                        else {
                            return num;
                        }
                    default:
                        return token.text;
                }
            }
            return;
        };
        var result = buildTree();
        if (postfix.length > 0) {
            var msg = 'Remaining tokens after building AST: \n';
            for (var i = postfix.length - 1; i >= 0; i--) {
                msg += postfix[i].type + ': ' + postfix[i].text + '\n';
            }
            throw new Error(msg);
        }
        return result;
    };
    CqlParser.prototype.read = function (text) {
        var _a = this, buildAst = _a.buildAst, tokenize = _a.tokenize;
        if (!text || text.length === 0) {
            return undefined;
        }
        var tokenizedText = tokenize(text);
        return buildAst(tokenizedText);
    };
    CqlParser.prototype.write = function (filter, isChild) {
        var _a = this, operatorReverseMap = _a.operatorReverseMap, combinationOperatorsReverseMap = _a.combinationOperatorsReverseMap, write = _a.write;
        if (!Array.isArray(filter) || filter.length < 2) {
            return undefined;
        }
        var operator = filter[0];
        var cqlOperator = operatorReverseMap[operator];
        switch (operator) {
            case '!':
                return "NOT ( " + write(filter[1]) + " )";
            case '&&':
            case '||':
                var cqlFilter = '';
                var cqlCombinationOperator = combinationOperatorsReverseMap[operator];
                cqlFilter += filter
                    .slice(1)
                    .map(function (f) { return write(f, true); })
                    .join(" " + cqlCombinationOperator + " ");
                if (isChild) {
                    return "(" + cqlFilter + ")";
                }
                else {
                    return cqlFilter;
                }
            case '==':
            case '*=':
            case '!=':
            case '<':
            case '<=':
            case '>':
            case '>=':
                var valueIsString = lodash_1.isString(filter[2]);
                var value = filter[2];
                if (valueIsString) {
                    value = "'" + value + "'";
                }
                return filter[1] + " " + cqlOperator + " " + value;
            case undefined:
                break;
            default:
                throw new Error("Can't encode: " + filter);
        }
        return;
    };
    return CqlParser;
}());
exports.CqlParser = CqlParser;
exports.default = CqlParser;
//# sourceMappingURL=CqlParser.js.map